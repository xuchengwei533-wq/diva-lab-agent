<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è¡¨æƒ…è¯†åˆ« + éŸ³é¢‘åˆ†æç³»ç»Ÿ</title>
  <script defer src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/meyda@5.2.1/dist/web/meyda.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f5f5f5;
      color: #333;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .header h2 {
      color: #2c3e50;
      margin-bottom: 15px;
      font-size: 2em;
    }

    .upload-section {
      margin-bottom: 20px;
    }

    .file-input-wrapper {
      position: relative;
      display: inline-block;
      margin: 0 10px;
    }

    .file-input-wrapper input[type=file] {
      position: absolute;
      left: -9999px;
      opacity: 0;
    }

    .file-input-label {
      display: inline-block;
      padding: 12px 30px;
      background: #3498db;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-size: 16px;
    }

    .file-input-label:hover {
      background: #2980b9;
    }

    .status {
      margin: 15px 0;
      padding: 10px;
      background: #e8f4fd;
      border: 2px solid #3498db;
      border-radius: 8px;
      color: #2980b9;
      font-weight: 500;
    }

    .debug-info {
      margin: 10px 0;
      padding: 8px;
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 4px;
      font-size: 12px;
      color: #856404;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .video-section, .realtime-audio-section {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .video-container { 
      position: relative; 
      width: 100%;
      max-width: 640px;
      height: 380px;
      margin: 0 auto;
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      background: #000;
    }

    #inputVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .chart-section {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }

    .chart-title {
      text-align: center;
      margin-bottom: 20px;
      color: #2c3e50;
      font-size: 1.5em;
    }

    .chart-container { 
      width: 100%;
      height: 300px;
      margin: 0 auto;
      position: relative;
    }

    .realtime-charts {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .realtime-chart {
      height: 200px;
      position: relative;
    }

    /* åˆ†æç»“æœåŒºåŸŸæ ·å¼ */
    .analysis-section {
      display: none;
      margin-top: 30px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
    }

    .stat-number {
      font-size: 1.5em;
      font-weight: bold;
      color: #3498db;
    }

    .stat-label {
      color: #666;
      margin-top: 5px;
      font-size: 0.9em;
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 30px;
      margin-bottom: 30px;
    }

    .chart-card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .chart-card h3 {
      text-align: center;
      margin-bottom: 20px;
      color: #2c3e50;
    }

    .export-buttons {
      text-align: center;
      margin-top: 20px;
    }

    .export-btn {
      display: inline-block;
      padding: 12px 24px;
      margin: 0 10px;
      background: #28a745;
      color: white;
      text-decoration: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      border: none;
      font-size: 16px;
    }

    .export-btn:hover {
      background: #218838;
    }

    .large-chart {
      grid-column: span 2;
    }

    .feature-section {
      margin-bottom: 40px;
    }

    .feature-title {
      text-align: center;
      font-size: 1.8em;
      color: #2c3e50;
      margin-bottom: 30px;
      padding: 20px 0;
      background: linear-gradient(45deg, #3498db, #2980b9);
      color: white;
      border-radius: 12px;
    }

    @media (max-width: 1200px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .charts-grid {
        grid-template-columns: 1fr;
      }

      .realtime-charts {
        grid-template-columns: 1fr;
      }

      .large-chart {
        grid-column: span 1;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>å¤šæ¨¡æ€æƒ…æ„Ÿåˆ†æç³»ç»Ÿ</h2>
      <p>åŸºäºè§†é¢‘è¡¨æƒ…è¯†åˆ«ä¸éŸ³é¢‘ç‰¹å¾åˆ†æçš„ç»¼åˆæƒ…æ„Ÿæ£€æµ‹</p>
      <div class="upload-section">
        <div class="file-input-wrapper">
          <input type="file" id="videoUpload" accept="video/*">
          <label for="videoUpload" class="file-input-label">
            ğŸ“¹ é€‰æ‹©è§†é¢‘æ–‡ä»¶
          </label>
        </div>
      </div>
      <div id="status" class="status">æ­£åœ¨åŠ è½½æ¨¡å‹...</div>
      <div id="debugInfo" class="debug-info">è°ƒè¯•ä¿¡æ¯å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div class="chart-title">è§†é¢‘è¡¨æƒ…è¯†åˆ«</div>
        <div class="video-container" id="videoContainer">
          <video id="inputVideo" controls crossorigin="anonymous"></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="chart-container" style="margin-top: 20px;">
          <canvas id="expressionChart"></canvas>
        </div>
      </div>

      <div class="realtime-audio-section">
        <div class="chart-title">å®æ—¶éŸ³é¢‘åˆ†æ</div>
        <div class="realtime-charts">
          <div class="realtime-chart">
            <canvas id="realtimeBasic"></canvas>
          </div>
          <div class="realtime-chart">
            <canvas id="realtimeSpectral"></canvas>
          </div>
          <div class="realtime-chart">
            <canvas id="realtimeMFCC"></canvas>
          </div>
          <div class="realtime-chart">
            <canvas id="realtimeLoudness"></canvas>
          </div>
        </div>
      </div>
    </div>

    <!-- åˆ†æç»“æœåŒºåŸŸ -->
    <div id="analysisSection" class="analysis-section">
      <h2 style="text-align: center; margin-bottom: 30px; color: #2c3e50;">ç»¼åˆåˆ†æç»“æœ</h2>
      
      <!-- ç»Ÿè®¡æ¦‚è§ˆ -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalFrames">0</div>
          <div class="stat-label">æ€»å¸§æ•°</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="dominantEmotion">-</div>
          <div class="stat-label">ä¸»è¦è¡¨æƒ…</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="videoDuration">0s</div>
          <div class="stat-label">è§†é¢‘æ—¶é•¿</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="avgRMS">0</div>
          <div class="stat-label">å¹³å‡å“åº¦</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="avgSpectralCentroid">0Hz</div>
          <div class="stat-label">å¹³å‡é¢‘è°±è´¨å¿ƒ</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="avgZCR">0</div>
          <div class="stat-label">å¹³å‡è¿‡é›¶ç‡</div>
        </div>
      </div>

      <!-- è§†è§‰åˆ†æ -->
      <div class="feature-section">
        <div class="feature-title">ğŸ­ è§†è§‰æƒ…æ„Ÿåˆ†æ</div>
        <div class="charts-grid">
          <div class="chart-card">
            <h3>è¡¨æƒ…å˜åŒ–æ—¶é—´çº¿</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="timelineChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>å¹³å‡è¡¨æƒ…åˆ†å¸ƒ</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="summaryChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- éŸ³é¢‘åŸºç¡€ç‰¹å¾åˆ†æ -->
      <div class="feature-section">
        <div class="feature-title">ğŸµ éŸ³é¢‘åŸºç¡€ç‰¹å¾åˆ†æ</div>
        <div class="charts-grid">
          <div class="chart-card large-chart">
            <h3>æ—¶åŸŸç‰¹å¾å˜åŒ– (RMS, ZCR, Energy)</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="timedomainChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>RMS åˆ†å¸ƒ</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="rmsDistChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>è¿‡é›¶ç‡åˆ†æ</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="zcrChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- é¢‘è°±ç‰¹å¾åˆ†æ -->
      <div class="feature-section">
        <div class="feature-title">ğŸ“Š é¢‘è°±ç‰¹å¾åˆ†æ</div>
        <div class="charts-grid">
          <div class="chart-card large-chart">
            <h3>é¢‘è°±ç‰¹å¾æ—¶é—´çº¿</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="spectralTimelineChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>é¢‘è°±è´¨å¿ƒåˆ†å¸ƒ</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="spectralCentroidChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>é¢‘è°±å¹³å¦åº¦</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="spectralFlatnessChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- MFCC å’Œ è‰²åº¦åˆ†æ -->
      <div class="feature-section">
        <div class="feature-title">ğŸ¼ é«˜çº§éŸ³é¢‘ç‰¹å¾</div>
        <div class="charts-grid">
          <div class="chart-card large-chart">
            <h3>MFCC çƒ­åŠ›å›¾</h3>
            <div style="height: 400px; position: relative;">
              <canvas id="mfccHeatmapChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>è‰²åº¦å‘é‡å¹³å‡å€¼</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="chromaChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>å“åº¦åˆ†å¸ƒ (Barké¢‘æ®µ)</h3>
            <div style="height: 300px; position: relative;">
              <canvas id="loudnessChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div class="export-buttons">
        <button id="exportData" class="export-btn">ğŸ“Š å¯¼å‡ºå®Œæ•´æ•°æ® (JSON)</button>
        <button id="exportAudioData" class="export-btn">ğŸµ å¯¼å‡ºéŸ³é¢‘ç‰¹å¾ (CSV)</button>
        <button id="exportChart" class="export-btn">ğŸ“ˆ å¯¼å‡ºæ—¶é—´çº¿å›¾è¡¨</button>
      </div>
    </div>
  </div>

  <script>
    window.addEventListener('load', async () => {
      const video = document.getElementById('inputVideo');
      const canvas = document.getElementById('overlay');
      const statusDiv = document.getElementById('status');
      const debugDiv = document.getElementById('debugInfo');
      const ctxChart = document.getElementById('expressionChart').getContext('2d');
      
      // æ•°æ®è®°å½•
      let emotionHistory = [];
      let audioHistory = [];
      let isRecording = false;
      let recordingStartTime = 0;
      let audioStartTime = 0;
      let audioContext = null;
      let sourceNode = null;
      let analyzer = null;
      let analysisStartTime = 0; // éŸ³é¢‘åˆ†æå¼€å§‹çš„ç»å¯¹æ—¶é—´

      // å®æ—¶å›¾è¡¨
      let realtimeCharts = {};

      // è°ƒè¯•å‡½æ•°
      function debugLog(message) {
        console.log(message);
        debugDiv.textContent = message;
      }

      // è¡¨æƒ…æ ‡ç­¾ï¼ˆä¸­è‹±æ–‡å¯¹ç…§ï¼‰
      const expressionLabels = ["neutral", "happy", "sad", "angry", "fearful", "disgusted", "surprised"];
      const expressionLabelsZH = ["å¹³é™", "å¼€å¿ƒ", "æ‚²ä¼¤", "æ„¤æ€’", "ææƒ§", "åŒæ¶", "æƒŠè®¶"];

      // éŸ³é¢‘ç‰¹å¾é…ç½®
      const audioFeatures = [
        'rms', 'zcr', 'energy',
        'spectralCentroid', 'spectralFlatness', 'spectralSlope', 
        'spectralRolloff', 'spectralSpread', 'spectralSkewness', 'spectralKurtosis',
        'perceptualSpread', 'perceptualSharpness',
        'chroma', 'mfcc', 'loudness'
      ];

      // åˆå§‹åŒ–å®æ—¶å›¾è¡¨
      function initializeRealtimeCharts() {
        // åŸºç¡€ç‰¹å¾å›¾è¡¨
        realtimeCharts.basic = new Chart(document.getElementById('realtimeBasic'), {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'RMS',
                data: [],
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                tension: 0.1
              },
              {
                label: 'ZCR',
                data: [],
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.1)',
                tension: 0.1,
                yAxisID: 'y1'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: 'åŸºç¡€ç‰¹å¾' }},
            scales: {
              y: { beginAtZero: true, title: { display: true, text: 'RMS' }},
              y1: { type: 'linear', display: true, position: 'right', beginAtZero: true, title: { display: true, text: 'ZCR' }}
            }
          }
        });

        // é¢‘è°±ç‰¹å¾å›¾è¡¨
        realtimeCharts.spectral = new Chart(document.getElementById('realtimeSpectral'), {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: 'é¢‘è°±è´¨å¿ƒ',
                data: [],
                borderColor: 'rgba(255, 206, 86, 1)',
                backgroundColor: 'rgba(255, 206, 86, 0.1)',
                tension: 0.1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: 'é¢‘è°±è´¨å¿ƒ' }},
            scales: { y: { beginAtZero: true, title: { display: true, text: 'Hz' }}}
          }
        });

        // MFCC å›¾è¡¨
        realtimeCharts.mfcc = new Chart(document.getElementById('realtimeMFCC'), {
          type: 'bar',
          data: {
            labels: Array.from({length: 13}, (_, i) => `MFCC${i+1}`),
            datasets: [{
              label: 'MFCC',
              data: Array(13).fill(0),
              backgroundColor: 'rgba(75, 192, 192, 0.6)',
              borderColor: 'rgba(75, 192, 192, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: 'MFCC ç‰¹å¾' }, legend: { display: false }},
            scales: { y: { title: { display: true, text: 'ç³»æ•°å€¼' }}}
          }
        });

        // å“åº¦å›¾è¡¨
        realtimeCharts.loudness = new Chart(document.getElementById('realtimeLoudness'), {
          type: 'bar',
          data: {
            labels: Array.from({length: 24}, (_, i) => `B${i+1}`),
            datasets: [{
              label: 'å“åº¦',
              data: Array(24).fill(0),
              backgroundColor: 'rgba(153, 102, 255, 0.6)',
              borderColor: 'rgba(153, 102, 255, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: 'Barké¢‘æ®µå“åº¦' }, legend: { display: false }},
            scales: { 
              y: { title: { display: true, text: 'å“åº¦å€¼' }},
              x: { display: false }
            }
          }
        });
      }

      // åˆå§‹åŒ– Chart.js æŸ±çŠ¶å›¾
      const chart = new Chart(ctxChart, {
        type: 'bar',
        data: {
          labels: expressionLabelsZH,
          datasets: [{
            label: "è¡¨æƒ…æ¦‚ç‡",
            data: Array(expressionLabels.length).fill(0),
            backgroundColor: [
              'rgba(108, 117, 125, 0.8)',
              'rgba(255, 193, 7, 0.8)',
              'rgba(52, 144, 220, 0.8)',
              'rgba(220, 53, 69, 0.8)',
              'rgba(111, 66, 193, 0.8)',
              'rgba(40, 167, 69, 0.8)',
              'rgba(253, 126, 20, 0.8)'
            ],
            borderColor: [
              'rgba(108, 117, 125, 1)',
              'rgba(255, 193, 7, 1)',
              'rgba(52, 144, 220, 1)',
              'rgba(220, 53, 69, 1)',
              'rgba(111, 66, 193, 1)',
              'rgba(40, 167, 69, 1)',
              'rgba(253, 126, 20, 1)'
            ],
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }},
          scales: {
            y: { beginAtZero: true, max: 1 },
            x: { title: { display: true, text: 'è¡¨æƒ…ç±»å‹' }}
          }
        }
      });

      // åŠ è½½æ¨¡å‹
      async function loadModels() {
        try {
          const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@latest/model';
          await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
          await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
          await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);
          
          statusDiv.innerText = "âœ… æ¨¡å‹åŠ è½½å®Œæˆï¼Œè¯·ä¸Šä¼ è§†é¢‘æ–‡ä»¶";
          statusDiv.style.background = '#d4edda';
          statusDiv.style.borderColor = '#28a745';
          statusDiv.style.color = '#155724';
          debugLog("æ¨¡å‹åŠ è½½å®Œæˆ");
        } catch (error) {
          console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error);
          statusDiv.innerText = "âŒ æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•";
          statusDiv.style.background = '#f8d7da';
          statusDiv.style.borderColor = '#dc3545';
          statusDiv.style.color = '#721c24';
          debugLog(`æ¨¡å‹åŠ è½½å¤±è´¥: ${error.message}`);
        }
      }

      // æ”¹è¿›çš„éŸ³é¢‘åˆ†æåˆå§‹åŒ–
      function initializeAudioAnalysis() {
        try {
          // å¦‚æœå·²æœ‰åˆ†æå™¨ï¼Œå…ˆåœæ­¢
          if (analyzer) {
            analyzer.stop();
          }
          if (audioContext && audioContext.state !== 'closed') {
            audioContext.close();
          }

          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          sourceNode = audioContext.createMediaElementSource(video);
          
          // è®°å½•éŸ³é¢‘åˆ†æå¼€å§‹æ—¶é—´
          analysisStartTime = Date.now();
          
          if (typeof Meyda !== 'undefined') {
            analyzer = Meyda.createMeydaAnalyzer({
              audioContext: audioContext,
              source: sourceNode,
              bufferSize: 1024,
              featureExtractors: audioFeatures,
              callback: (features) => {
                if (isRecording && features && video && !video.paused && !video.ended) {
                  // ä½¿ç”¨å¤šç§æ–¹æ³•è·å–æ—¶é—´æˆ³ï¼Œä¼˜å…ˆä½¿ç”¨è§†é¢‘æ—¶é—´
                  let currentTimestamp;
                  
                  // æ–¹æ³•1ï¼šä¼˜å…ˆä½¿ç”¨è§†é¢‘å½“å‰æ—¶é—´
                  if (video.currentTime > 0) {
                    currentTimestamp = video.currentTime;
                  } 
                  // æ–¹æ³•2ï¼šå¦‚æœè§†é¢‘æ—¶é—´ä¸º0ï¼Œä½¿ç”¨ç›¸å¯¹æ—¶é—´
                  else {
                    const elapsedMs = Date.now() - analysisStartTime;
                    currentTimestamp = elapsedMs / 1000; // è½¬æ¢ä¸ºç§’
                  }
                  
                  // è®°å½•éŸ³é¢‘ç‰¹å¾æ•°æ®
                  audioHistory.push({
                    timestamp: currentTimestamp,
                    features: {...features},
                    videoTime: video.currentTime, // åŒæ—¶è®°å½•è§†é¢‘æ—¶é—´ç”¨äºè°ƒè¯•
                    absoluteTime: Date.now() - analysisStartTime // è®°å½•ç»å¯¹æ—¶é—´å·®
                  });

                  // æ›´æ–°å®æ—¶å›¾è¡¨
                  updateRealtimeCharts(features, currentTimestamp);
                  
                  // è°ƒè¯•ä¿¡æ¯
                  if (audioHistory.length % 10 === 0) { // æ¯10å¸§è¾“å‡ºä¸€æ¬¡è°ƒè¯•ä¿¡æ¯
                    debugLog(`éŸ³é¢‘å¸§ ${audioHistory.length}: æ—¶é—´=${currentTimestamp.toFixed(2)}s, è§†é¢‘æ—¶é—´=${video.currentTime.toFixed(2)}s, RMS=${features.rms?.toFixed(3)}`);
                  }
                }
              }
            });

            // è¿æ¥åˆ°è¾“å‡ºï¼ˆå…è®¸å¬åˆ°å£°éŸ³ï¼‰
            sourceNode.connect(audioContext.destination);
            
            debugLog('Meyda éŸ³é¢‘åˆ†æåˆå§‹åŒ–æˆåŠŸ');
          } else {
            debugLog('Meyda åº“æœªåŠ è½½');
          }
        } catch (error) {
          debugLog(`éŸ³é¢‘åˆ†æåˆå§‹åŒ–å¤±è´¥: ${error.message}`);
          console.error('éŸ³é¢‘åˆ†æåˆå§‹åŒ–å¤±è´¥:', error);
        }
      }

      // æ›´æ–°å®æ—¶å›¾è¡¨
      function updateRealtimeCharts(features, timestamp) {
        const currentTime = Math.round(timestamp * 10) / 10; // ä¿ç•™1ä½å°æ•°

        // æ›´æ–°åŸºç¡€ç‰¹å¾å›¾è¡¨
        if (features.rms !== undefined && features.zcr !== undefined) {
          const basicChart = realtimeCharts.basic;
          if (basicChart.data.labels.length > 50) {
            basicChart.data.labels.shift();
            basicChart.data.datasets[0].data.shift();
            basicChart.data.datasets[1].data.shift();
          }
          basicChart.data.labels.push(currentTime);
          basicChart.data.datasets[0].data.push(features.rms);
          basicChart.data.datasets[1].data.push(features.zcr);
          basicChart.update('none');
        }

        // æ›´æ–°é¢‘è°±ç‰¹å¾å›¾è¡¨
        if (features.spectralCentroid !== undefined) {
          const spectralChart = realtimeCharts.spectral;
          if (spectralChart.data.labels.length > 50) {
            spectralChart.data.labels.shift();
            spectralChart.data.datasets[0].data.shift();
          }
          spectralChart.data.labels.push(currentTime);
          spectralChart.data.datasets[0].data.push(features.spectralCentroid);
          spectralChart.update('none');
        }

        // æ›´æ–°MFCCå›¾è¡¨
        if (features.mfcc && Array.isArray(features.mfcc)) {
          const mfccChart = realtimeCharts.mfcc;
          mfccChart.data.datasets[0].data = features.mfcc.slice(0, 13);
          mfccChart.update('none');
        }

        // æ›´æ–°å“åº¦å›¾è¡¨
        if (features.loudness && features.loudness.specific && Array.isArray(features.loudness.specific)) {
          const loudnessChart = realtimeCharts.loudness;
          loudnessChart.data.datasets[0].data = features.loudness.specific.slice(0, 24);
          loudnessChart.update('none');
        }
      }

      // åŠ è½½æ¨¡å‹å’Œåˆå§‹åŒ–å›¾è¡¨
      await loadModels();
      initializeRealtimeCharts();

      // ä¸Šä¼ è§†é¢‘
      document.getElementById('videoUpload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // é‡ç½®æ•°æ®
        emotionHistory = [];
        audioHistory = [];
        isRecording = false;
        document.getElementById('analysisSection').style.display = 'none';

        const url = URL.createObjectURL(file);
        video.src = url;
        video.muted = false; // å…è®¸éŸ³é¢‘æ’­æ”¾ä»¥ä¾¿åˆ†æ
        
        statusDiv.innerText = "ğŸ“¹ è§†é¢‘å·²åŠ è½½ï¼Œå¼€å§‹æ’­æ”¾è¿›è¡Œæ£€æµ‹";
        debugLog(`è§†é¢‘æ–‡ä»¶åŠ è½½: ${file.name}, å¤§å°: ${(file.size / 1024 / 1024).toFixed(2)}MB`);

        video.onloadedmetadata = () => {
          const container = document.getElementById('videoContainer');
          canvas.width = container.offsetWidth;
          canvas.height = container.offsetHeight;
          debugLog(`è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆï¼Œæ—¶é•¿: ${video.duration.toFixed(2)}s`);
        };
      });

      // æ”¹è¿›çš„è§†é¢‘æ’­æ”¾äº‹ä»¶å¤„ç†
      video.addEventListener('play', () => {
        debugLog(`è§†é¢‘å¼€å§‹æ’­æ”¾ï¼Œå½“å‰æ—¶é—´: ${video.currentTime}`);
        
        const container = document.getElementById('videoContainer');
        const displaySize = { width: container.offsetWidth, height: container.offsetHeight };
        faceapi.matchDimensions(canvas, displaySize);
        
        // å¼€å§‹è®°å½•
        isRecording = true;
        recordingStartTime = Date.now();
        audioStartTime = Date.now();

        // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            debugLog('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤');
          });
        }

        // å¯åŠ¨éŸ³é¢‘åˆ†æï¼ˆåœ¨è§†é¢‘æ’­æ”¾åï¼‰
        setTimeout(() => {
          if (!analyzer) {
            initializeAudioAnalysis();
          }
          if (analyzer) {
            analyzer.start();
            debugLog('éŸ³é¢‘åˆ†æå·²å¯åŠ¨');
          }
        }, 100); // å»¶è¿Ÿ100mså¯åŠ¨éŸ³é¢‘åˆ†æ

        async function runDetection() {
          if (video.paused || video.ended) return;

          try {
            const detections = await faceapi
              .detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
              .withFaceLandmarks()
              .withFaceExpressions();

            const resizedDetections = faceapi.resizeResults(detections, displaySize);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (resizedDetections.length > 0) {
              const face = resizedDetections[0];
              faceapi.draw.drawDetections(canvas, [face]);
              faceapi.draw.drawFaceLandmarks(canvas, [face]);
              faceapi.draw.drawFaceExpressions(canvas, [face]);

              // æ›´æ–°æŸ±çŠ¶å›¾æ•°æ®
              const expressions = face.expressions;
              chart.data.datasets[0].data = expressionLabels.map(e => expressions[e] || 0);
              chart.update('none');

              // è®°å½•æ•°æ®
              if (isRecording) {
                const emotionData = {
                  timestamp: video.currentTime,
                  expressions: { ...expressions }
                };
                emotionHistory.push(emotionData);
              }

              statusDiv.innerText = `âœ… æ­£åœ¨æ£€æµ‹è¡¨æƒ…å’ŒéŸ³é¢‘... (è§†é¢‘å¸§: ${emotionHistory.length}, éŸ³é¢‘å¸§: ${audioHistory.length}, æ—¶é—´: ${video.currentTime.toFixed(2)}s)`;
            } else {
              statusDiv.innerText = `âš ï¸ æœªæ£€æµ‹åˆ°äººè„¸ (éŸ³é¢‘å¸§: ${audioHistory.length}, æ—¶é—´: ${video.currentTime.toFixed(2)}s)`;
            }
          } catch (error) {
            console.error('æ£€æµ‹é”™è¯¯:', error);
            debugLog(`æ£€æµ‹é”™è¯¯: ${error.message}`);
          }

          requestAnimationFrame(runDetection);
        }

        runDetection();
      });

      // è§†é¢‘æš‚åœæ—¶åœæ­¢éŸ³é¢‘åˆ†æ
      video.addEventListener('pause', () => {
        debugLog('è§†é¢‘æš‚åœï¼Œåœæ­¢éŸ³é¢‘åˆ†æ');
        if (analyzer) {
          analyzer.stop();
        }
      });

      // è§†é¢‘ç»“æŸäº‹ä»¶
      video.addEventListener('ended', () => {
        isRecording = false;
        if (analyzer) {
          analyzer.stop();
        }
        statusDiv.innerText = `ğŸ¬ åˆ†æå®Œæˆï¼è§†é¢‘å¸§: ${emotionHistory.length}, éŸ³é¢‘å¸§: ${audioHistory.length}`;
        statusDiv.style.background = '#d1ecf1';
        statusDiv.style.borderColor = '#17a2b8';
        statusDiv.style.color = '#0c5460';
        
        debugLog(`åˆ†æå®Œæˆ - è§†é¢‘å¸§: ${emotionHistory.length}, éŸ³é¢‘å¸§: ${audioHistory.length}`);
        
        // è¾“å‡ºæ—¶é—´æˆ³è°ƒè¯•ä¿¡æ¯
        if (audioHistory.length > 0) {
          const firstAudio = audioHistory[0];
          const lastAudio = audioHistory[audioHistory.length - 1];
          debugLog(`éŸ³é¢‘æ—¶é—´æˆ³èŒƒå›´: ${firstAudio.timestamp.toFixed(2)}s - ${lastAudio.timestamp.toFixed(2)}s`);
        }
        
        generateAnalysisReport();
      });

      // ç”Ÿæˆåˆ†ææŠ¥å‘Š
      function generateAnalysisReport() {
        const analysisSection = document.getElementById('analysisSection');
        analysisSection.style.display = 'block';
        analysisSection.scrollIntoView({ behavior: 'smooth' });

        updateStatistics();
        generateVisualCharts();
        generateAudioCharts();
        initializeExportButtons();
      }

      // æ›´æ–°ç»Ÿè®¡æ•°æ®
      function updateStatistics() {
        const validEmotionData = emotionHistory.filter(d => d.expressions);
        const validAudioData = audioHistory.filter(d => d.features && d.features.rms !== undefined);
        
        // åŸºç¡€ç»Ÿè®¡
        document.getElementById('totalFrames').textContent = emotionHistory.length;
        document.getElementById('videoDuration').textContent = `${Math.round(video.duration)}s`;

        // è¡¨æƒ…ç»Ÿè®¡
        if (validEmotionData.length > 0) {
          const emotionTotals = {};
          expressionLabels.forEach(label => emotionTotals[label] = 0);
          
          validEmotionData.forEach(data => {
            Object.entries(data.expressions).forEach(([emotion, value]) => {
              emotionTotals[emotion] += value;
            });
          });

          const dominantEmotion = Object.entries(emotionTotals).reduce((a, b) => 
            emotionTotals[a[0]] > emotionTotals[b[0]] ? a : b
          )[0];
          
          document.getElementById('dominantEmotion').textContent = 
            expressionLabelsZH[expressionLabels.indexOf(dominantEmotion)];
        }

        // éŸ³é¢‘ç»Ÿè®¡
        if (validAudioData.length > 0) {
          const avgRMS = validAudioData.reduce((sum, d) => sum + (d.features.rms || 0), 0) / validAudioData.length;
          const avgSpectralCentroid = validAudioData.reduce((sum, d) => sum + (d.features.spectralCentroid || 0), 0) / validAudioData.length;
          const avgZCR = validAudioData.reduce((sum, d) => sum + (d.features.zcr || 0), 0) / validAudioData.length;
          
          document.getElementById('avgRMS').textContent = avgRMS.toFixed(3);
          document.getElementById('avgSpectralCentroid').textContent = `${Math.round(avgSpectralCentroid)}Hz`;
          document.getElementById('avgZCR').textContent = avgZCR.toFixed(3);
        }
      }

      // ç”Ÿæˆè§†è§‰å›¾è¡¨
      function generateVisualCharts() {
        if (emotionHistory.length === 0) return;

        const validData = emotionHistory.filter(d => d.expressions);
        
        // è¡¨æƒ…æ—¶é—´çº¿
        const timelineCtx = document.getElementById('timelineChart').getContext('2d');
        const datasets = expressionLabels.map((label, index) => ({
          label: expressionLabelsZH[index],
          data: validData.map(d => ({ x: d.timestamp, y: d.expressions[label] || 0 })),
          borderColor: [
            'rgba(108, 117, 125, 1)', 'rgba(255, 193, 7, 1)', 'rgba(52, 144, 220, 1)',
            'rgba(220, 53, 69, 1)', 'rgba(111, 66, 193, 1)', 'rgba(40, 167, 69, 1)', 'rgba(253, 126, 20, 1)'
          ][index],
          backgroundColor: [
            'rgba(108, 117, 125, 0.1)', 'rgba(255, 193, 7, 0.1)', 'rgba(52, 144, 220, 0.1)',
            'rgba(220, 53, 69, 0.1)', 'rgba(111, 66, 193, 0.1)', 'rgba(40, 167, 69, 0.1)', 'rgba(253, 126, 20, 0.1)'
          ][index],
          tension: 0.1,
          pointRadius: 1
        }));

        new Chart(timelineCtx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { type: 'linear', title: { display: true, text: 'æ—¶é—´ (ç§’)' }},
              y: { beginAtZero: true, max: 1, title: { display: true, text: 'æ¦‚ç‡' }}
            }
          }
        });

        // è¡¨æƒ…åˆ†å¸ƒé¥¼å›¾
        const summaryCtx = document.getElementById('summaryChart').getContext('2d');
        const emotionTotals = {};
        expressionLabels.forEach(label => emotionTotals[label] = 0);
        
        validData.forEach(data => {
          Object.entries(data.expressions).forEach(([emotion, value]) => {
            emotionTotals[emotion] += value;
          });
        });

        const averages = expressionLabels.map(label => emotionTotals[label] / validData.length);
        
        new Chart(summaryCtx, {
          type: 'doughnut',
          data: {
            labels: expressionLabelsZH,
            datasets: [{
              data: averages,
              backgroundColor: [
                'rgba(108, 117, 125, 0.8)', 'rgba(255, 193, 7, 0.8)', 'rgba(52, 144, 220, 0.8)',
                'rgba(220, 53, 69, 0.8)', 'rgba(111, 66, 193, 0.8)', 'rgba(40, 167, 69, 0.8)', 'rgba(253, 126, 20, 0.8)'
              ]
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { position: 'right' }}
          }
        });
      }

      // ç”ŸæˆéŸ³é¢‘å›¾è¡¨
      function generateAudioCharts() {
        if (audioHistory.length === 0) return;

        const validData = audioHistory.filter(d => d.features && d.features.rms !== undefined);
        if (validData.length === 0) return;

        debugLog(`ç”ŸæˆéŸ³é¢‘å›¾è¡¨ï¼Œæœ‰æ•ˆæ•°æ®ç‚¹: ${validData.length}`);
        
        // è¾“å‡ºæ—¶é—´æˆ³èŒƒå›´ç”¨äºè°ƒè¯•
        if (validData.length > 0) {
          const firstTime = validData[0].timestamp;
          const lastTime = validData[validData.length - 1].timestamp;
          debugLog(`éŸ³é¢‘æ•°æ®æ—¶é—´èŒƒå›´: ${firstTime.toFixed(2)}s - ${lastTime.toFixed(2)}s`);
        }

        // æ—¶åŸŸç‰¹å¾
        generateTimedomainCharts(validData);
        
        // é¢‘è°±ç‰¹å¾
        generateSpectralCharts(validData);
        
        // é«˜çº§ç‰¹å¾
        generateAdvancedCharts(validData);
      }

      // ç”Ÿæˆæ—¶åŸŸç‰¹å¾å›¾è¡¨ï¼ˆä¿®å¤æ—¶é—´æˆ³é—®é¢˜ï¼‰
      function generateTimedomainCharts(data) {
        // æ—¶åŸŸç‰¹å¾æ—¶é—´çº¿
        const timedomainCtx = document.getElementById('timedomainChart').getContext('2d');
        
        // æ£€æŸ¥æ•°æ®å’Œæ—¶é—´æˆ³
        console.log('æ—¶åŸŸå›¾è¡¨æ•°æ®sample:', data.slice(0, 5).map(d => ({
          timestamp: d.timestamp,
          rms: d.features.rms,
          zcr: d.features.zcr
        })));
        
        new Chart(timedomainCtx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'RMS',
                data: data.map(d => ({ x: d.timestamp, y: d.features.rms || 0 })),
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                yAxisID: 'y',
                tension: 0.1,
                pointRadius: 1
              },
              {
                label: 'ZCR',
                data: data.map(d => ({ x: d.timestamp, y: d.features.zcr || 0 })),
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.1)',
                yAxisID: 'y1',
                tension: 0.1,
                pointRadius: 1
              },
              {
                label: 'Energy',
                data: data.map(d => ({ x: d.timestamp, y: d.features.energy || 0 })),
                borderColor: 'rgba(255, 206, 86, 1)',
                backgroundColor: 'rgba(255, 206, 86, 0.1)',
                yAxisID: 'y2',
                tension: 0.1,
                pointRadius: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              intersect: false,
              mode: 'index'
            },
            scales: {
              x: { 
                type: 'linear',
                title: { display: true, text: 'æ—¶é—´ (ç§’)' },
                min: 0  // ç¡®ä¿ä»0å¼€å§‹
              },
              y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'RMS' }},
              y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'ZCR' }},
              y2: { type: 'linear', display: false }
            }
          }
        });

        // RMSåˆ†å¸ƒç›´æ–¹å›¾
        const rmsData = data.map(d => d.features.rms).filter(v => v !== undefined);
        const rmsHist = createHistogram(rmsData, 20);
        const rmsCtx = document.getElementById('rmsDistChart').getContext('2d');
        new Chart(rmsCtx, {
          type: 'bar',
          data: {
            labels: rmsHist.labels,
            datasets: [{
              label: 'é¢‘æ¬¡',
              data: rmsHist.counts,
              backgroundColor: 'rgba(255, 99, 132, 0.6)',
              borderColor: 'rgba(255, 99, 132, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'RMS å€¼' }},
              y: { title: { display: true, text: 'é¢‘æ¬¡' }}
            }
          }
        });

        // è¿‡é›¶ç‡åˆ†æ
        const zcrCtx = document.getElementById('zcrChart').getContext('2d');
        new Chart(zcrCtx, {
          type: 'line',
          data: {
            datasets: [{
              label: 'è¿‡é›¶ç‡',
              data: data.map(d => ({ x: d.timestamp, y: d.features.zcr || 0 })),
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.1)',
              tension: 0.1,
              pointRadius: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { 
                type: 'linear',
                title: { display: true, text: 'æ—¶é—´ (ç§’)' },
                min: 0
              },
              y: { title: { display: true, text: 'ZCR' }}
            }
          }
        });
      }

      // ç”Ÿæˆé¢‘è°±ç‰¹å¾å›¾è¡¨
      function generateSpectralCharts(data) {
        // é¢‘è°±ç‰¹å¾æ—¶é—´çº¿
        const spectralTimelineCtx = document.getElementById('spectralTimelineChart').getContext('2d');
        new Chart(spectralTimelineCtx, {
          type: 'line',
          data: {
            datasets: [
              {
                label: 'é¢‘è°±è´¨å¿ƒ',
                data: data.map(d => ({ x: d.timestamp, y: d.features.spectralCentroid || 0 })),
                borderColor: 'rgba(255, 206, 86, 1)',
                yAxisID: 'y',
                tension: 0.1,
                pointRadius: 1
              },
              {
                label: 'é¢‘è°±å¹³å¦åº¦',
                data: data.map(d => ({ x: d.timestamp, y: d.features.spectralFlatness || 0 })),
                borderColor: 'rgba(75, 192, 192, 1)',
                yAxisID: 'y1',
                tension: 0.1,
                pointRadius: 1
              },
              {
                label: 'é¢‘è°±æ»šé™ç‚¹',
                data: data.map(d => ({ x: d.timestamp, y: d.features.spectralRolloff || 0 })),
                borderColor: 'rgba(153, 102, 255, 1)',
                yAxisID: 'y',
                tension: 0.1,
                pointRadius: 1
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { 
                type: 'linear',
                title: { display: true, text: 'æ—¶é—´ (ç§’)' },
                min: 0
              },
              y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'é¢‘ç‡ (Hz)' }},
              y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: 'å¹³å¦åº¦' }}
            }
          }
        });

        // é¢‘è°±è´¨å¿ƒåˆ†å¸ƒ
        const centroidData = data.map(d => d.features.spectralCentroid).filter(v => v !== undefined);
        const centroidHist = createHistogram(centroidData, 15);
        const centroidCtx = document.getElementById('spectralCentroidChart').getContext('2d');
        new Chart(centroidCtx, {
          type: 'bar',
          data: {
            labels: centroidHist.labels,
            datasets: [{
              label: 'é¢‘æ¬¡',
              data: centroidHist.counts,
              backgroundColor: 'rgba(255, 206, 86, 0.6)',
              borderColor: 'rgba(255, 206, 86, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'é¢‘è°±è´¨å¿ƒ (Hz)' }},
              y: { title: { display: true, text: 'é¢‘æ¬¡' }}
            }
          }
        });

        // é¢‘è°±å¹³å¦åº¦
        const flatnessCtx = document.getElementById('spectralFlatnessChart').getContext('2d');
        new Chart(flatnessCtx, {
          type: 'line',
          data: {
            datasets: [{
              label: 'é¢‘è°±å¹³å¦åº¦',
              data: data.map(d => ({ x: d.timestamp, y: d.features.spectralFlatness || 0 })),
              borderColor: 'rgba(75, 192, 192, 1)',
              backgroundColor: 'rgba(75, 192, 192, 0.1)',
              tension: 0.1,
              pointRadius: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { 
                type: 'linear',
                title: { display: true, text: 'æ—¶é—´ (ç§’)' },
                min: 0
              },
              y: { title: { display: true, text: 'å¹³å¦åº¦' }}
            }
          }
        });
      }

      // ç”Ÿæˆé«˜çº§ç‰¹å¾å›¾è¡¨
      function generateAdvancedCharts(data) {
        // MFCC çƒ­åŠ›å›¾
        generateMFCCHeatmap(data);
        
        // è‰²åº¦ç‰¹å¾
        generateChromaChart(data);
        
        // å“åº¦åˆ†æ
        generateLoudnessChart(data);
      }

      // ç”ŸæˆMFCCçƒ­åŠ›å›¾
      function generateMFCCHeatmap(data) {
        const mfccData = data.filter(d => d.features.mfcc && Array.isArray(d.features.mfcc));
        if (mfccData.length === 0) return;

        const ctx = document.getElementById('mfccHeatmapChart').getContext('2d');
        
        // åˆ›å»ºç®€åŒ–çš„MFCCå¯è§†åŒ–ï¼ˆä½œä¸ºçº¿å›¾ï¼‰
        const mfccDatasets = [];
        for (let i = 0; i < 13; i++) {
          mfccDatasets.push({
            label: `MFCC ${i + 1}`,
            data: mfccData.map(d => ({ x: d.timestamp, y: d.features.mfcc[i] || 0 })),
            borderColor: `hsl(${i * 30}, 70%, 50%)`,
            backgroundColor: `hsla(${i * 30}, 70%, 50%, 0.1)`,
            tension: 0.1,
            pointRadius: 0
          });
        }

        new Chart(ctx, {
          type: 'line',
          data: { datasets: mfccDatasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              title: { display: true, text: 'MFCC ç³»æ•°æ—¶é—´å˜åŒ–' },
              legend: { position: 'right' }
            },
            scales: {
              x: { 
                type: 'linear',
                title: { display: true, text: 'æ—¶é—´ (ç§’)' },
                min: 0
              },
              y: { title: { display: true, text: 'MFCC ç³»æ•°å€¼' }}
            }
          }
        });
      }

      // ç”Ÿæˆè‰²åº¦å›¾è¡¨
      function generateChromaChart(data) {
        const chromaData = data.filter(d => d.features.chroma && Array.isArray(d.features.chroma));
        if (chromaData.length === 0) return;

        const ctx = document.getElementById('chromaChart').getContext('2d');
        
        // è®¡ç®—å¹³å‡è‰²åº¦å‘é‡
        const avgChroma = Array(12).fill(0);
        chromaData.forEach(d => {
          d.features.chroma.forEach((val, i) => {
            if (i < 12) avgChroma[i] += val;
          });
        });
        avgChroma.forEach((val, i) => avgChroma[i] /= chromaData.length);

        const chromaLabels = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        new Chart(ctx, {
          type: 'radar',
          data: {
            labels: chromaLabels,
            datasets: [{
              label: 'å¹³å‡è‰²åº¦',
              data: avgChroma,
              fill: true,
              backgroundColor: 'rgba(255, 99, 132, 0.2)',
              borderColor: 'rgba(255, 99, 132, 1)',
              pointBackgroundColor: 'rgba(255, 99, 132, 1)',
              pointBorderColor: '#fff',
              pointHoverBackgroundColor: '#fff',
              pointHoverBorderColor: 'rgba(255, 99, 132, 1)'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false }},
            scales: {
              r: {
                beginAtZero: true,
                title: { display: true, text: 'å¼ºåº¦' }
              }
            }
          }
        });
      }

      // ç”Ÿæˆå“åº¦å›¾è¡¨
      function generateLoudnessChart(data) {
        const loudnessData = data.filter(d => 
          d.features.loudness && 
          d.features.loudness.specific && 
          Array.isArray(d.features.loudness.specific)
        );
        if (loudnessData.length === 0) return;

        const ctx = document.getElementById('loudnessChart').getContext('2d');
        
        // è®¡ç®—å¹³å‡å“åº¦åˆ†å¸ƒ
        const avgLoudness = Array(24).fill(0);
        loudnessData.forEach(d => {
          d.features.loudness.specific.forEach((val, i) => {
            if (i < 24) avgLoudness[i] += val;
          });
        });
        avgLoudness.forEach((val, i) => avgLoudness[i] /= loudnessData.length);

        const barkLabels = Array.from({length: 24}, (_, i) => `Bark ${i + 1}`);

        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: barkLabels,
            datasets: [{
              label: 'å¹³å‡å“åº¦',
              data: avgLoudness,
              backgroundColor: 'rgba(153, 102, 255, 0.6)',
              borderColor: 'rgba(153, 102, 255, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false }},
            scales: {
              x: { 
                title: { display: true, text: 'Bark é¢‘æ®µ' },
                display: false
              },
              y: { title: { display: true, text: 'å“åº¦' }}
            }
          }
        });
      }

      // åˆ›å»ºç›´æ–¹å›¾æ•°æ®
      function createHistogram(data, bins) {
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binSize = (max - min) / bins;
        
        const counts = Array(bins).fill(0);
        const labels = [];
        
        for (let i = 0; i < bins; i++) {
          labels.push((min + i * binSize).toFixed(3));
        }
        
        data.forEach(value => {
          const bin = Math.min(Math.floor((value - min) / binSize), bins - 1);
          counts[bin]++;
        });
        
        return { labels, counts };
      }

      // åˆå§‹åŒ–å¯¼å‡ºåŠŸèƒ½
      function initializeExportButtons() {
        // å¯¼å‡ºå®Œæ•´æ•°æ®
        document.getElementById('exportData').addEventListener('click', () => {
          const dataToExport = {
            metadata: {
              totalFrames: emotionHistory.length,
              audioFrames: audioHistory.length,
              duration: video.duration,
              exportTime: new Date().toISOString()
            },
            emotionData: emotionHistory,
            audioData: audioHistory
          };
          
          const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { 
            type: 'application/json' 
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `multimodal-analysis-${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(url);
        });

        // å¯¼å‡ºéŸ³é¢‘ç‰¹å¾CSV
        document.getElementById('exportAudioData').addEventListener('click', () => {
          if (audioHistory.length === 0) {
            alert('æ²¡æœ‰éŸ³é¢‘æ•°æ®å¯å¯¼å‡º');
            return;
          }
          
          const csvHeader = ['timestamp', ...audioFeatures.flatMap(feature => {
            const sample = audioHistory.find(d => d.features && d.features[feature]);
            if (!sample) return [feature];
            
            const value = sample.features[feature];
            if (Array.isArray(value)) {
              return value.map((_, i) => `${feature}_${i}`);
            } else if (typeof value === 'object' && value !== null) {
              return Object.keys(value).map(key => `${feature}_${key}`);
            } else {
              return [feature];
            }
          })];
          
          const csvRows = [csvHeader.join(',')];
          
          audioHistory.forEach(row => {
            const values = [row.timestamp];
            audioFeatures.forEach(feature => {
              const value = row.features ? row.features[feature] : null;
              if (Array.isArray(value)) {
                values.push(...value.map(v => v || 0));
              } else if (typeof value === 'object' && value !== null) {
                Object.values(value).forEach(v => values.push(v || 0));
              } else {
                values.push(value || 0);
              }
            });
            csvRows.push(values.join(','));
          });
          
          const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `audio-features-${Date.now()}.csv`;
          a.click();
          URL.revokeObjectURL(url);
        });

        // å¯¼å‡ºå›¾è¡¨
        document.getElementById('exportChart').addEventListener('click', () => {
          const timelineCanvas = document.getElementById('timelineChart');
          const link = document.createElement('a');
          link.download = `analysis-timeline-${Date.now()}.png`;
          link.href = timelineCanvas.toDataURL();
          link.click();
        });
      }
    });
  </script>
</body>
</html>