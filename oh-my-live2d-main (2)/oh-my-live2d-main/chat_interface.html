<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æ»´å“‡ - èŠå¤©ç•Œé¢</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      height: 100vh;
      overflow: hidden;
    }

    .back-link-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10000;
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      text-decoration: none;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      border: none;
      cursor: pointer;
    }
    .back-link-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, #ee5a24, #ff6b6b);
    }

    .container {
      display: flex;
      height: 100vh;
      padding: 20px;
      gap: 20px;
    }

    .character-section {
      flex: 0 0 35%;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .character-title {
      color: white;
      font-size: 24px;
      margin-bottom: 20px;
      text-align: center;
    }
    .character-info {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      text-align: center;
      margin-top: 20px;
      line-height: 1.5;
    }
    #oml2d-container {
      width: 100%;
      height: 400px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .chat-section {
      flex: 0 0 65%;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .chat-header {
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      background: white;
      border-radius: 20px 20px 0 0;
    }
    .chat-title { font-size: 20px; font-weight: bold; color: #333; }
    .chat-subtitle { font-size: 14px; color: #666; margin-top: 5px; }

    .chat-messages {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .message {
      max-width: 70%;
      padding: 12px 16px;
      border-radius: 18px;
      line-height: 1.4;
      word-wrap: break-word;
      white-space: pre-wrap;
    }
    .message-bot {
      align-self: flex-start;
      background: #f0f0f0;
      color: #333;
      border-bottom-left-radius: 4px;
    }
    .message-user {
      align-self: flex-end;
      background: #667eea;
      color: white;
      border-bottom-right-radius: 4px;
    }

    .chat-input-area {
      padding: 20px;
      border-top: 1px solid #e0e0e0;
      background: white;
      border-radius: 0 0 20px 20px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .input-group {
      display: flex;
      gap: 10px;
      flex: 1 1 520px;
      min-width: 320px;
    }
    .chat-input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 25px;
      outline: none;
      font-size: 14px;
      transition: border-color 0.3s;
    }
    .chat-input:focus { border-color: #667eea; }
    .send-button {
      padding: 12px 24px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
      white-space: nowrap;
    }
    .send-button:hover { background: #5a6fd8; }

    .voice-button {
      padding: 12px;
      background: #ff6b6b;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      flex: 0 0 auto;
    }
    .voice-button:hover { background: #ee5a24; transform: scale(1.1); }
    .voice-button.recording { background: #ff4757; animation: pulse 1.5s infinite; }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .voice-status {
      font-size: 12px;
      color: #666;
      text-align: center;
      margin-top: 5px;
      flex: 1 1 200px;
      min-width: 180px;
    }

    .audio-score-trigger {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      flex: 0 0 auto;
    }
    .audio-score-trigger:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    #ttsToggle {
      background: linear-gradient(135deg, #2ed573 0%, #1e90ff 100%);
    }

    .audio-scoring-modal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    .audio-scoring-modal.active { display: flex; }

    .audio-scoring-section {
      background: white;
      border-radius: 15px;
      padding: 30px;
      width: 800px;
      max-width: 95%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      position: relative;
      max-height: 90vh;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .scoring-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
      gap: 10px;
      flex-wrap: wrap;
    }
    .close-modal {
      background: #ff6b6b;
      color: white;
      border: none;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .close-modal:hover { background: #ff5252; }

    .loading { text-align: center; padding: 20px; color: #666; }
    .error { color: #ff6b6b; font-size: 12px; margin-top: 5px; }

    .voice-selection { margin-bottom: 10px; }
    .voice-selection label { display: block; margin-bottom: 5px; font-size: 12px; color: #555; }
    .voice-select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; background: white; }

    .file-upload { margin-bottom: 10px; }
    .file-input { display: none; }
    .file-label {
      display: block;
      padding: 10px;
      background: #667eea;
      color: white;
      border-radius: 5px;
      text-align: center;
      cursor: pointer;
      transition: background 0.3s;
    }
    .file-label:hover { background: #5a6fd8; }

    .score-button {
      width: 100%;
      padding: 10px;
      background: #ff6b6b;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
    }
    .score-button:hover { background: #ee5a24; }

    .scoring-results {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #eee;
      max-height: 600px;
      overflow-y: auto;
    }
    .overall-score { text-align: center; margin-bottom: 15px; }
    .score-label { font-size: 14px; color: #666; }
    .score-value { font-size: 24px; font-weight: bold; color: #667eea; }

    .technique { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-top: 10px; }
    .technique-item {
      padding: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px;
      text-align: center;
      font-size: 12px;
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .technique-name { font-weight: bold; font-size: 11px; margin-bottom: 4px; }
    .technique-score {
      font-size: 14px;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      padding: 2px 4px;
    }

    .chart-container {
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .chart-title { font-weight: bold; color: #333; margin-bottom: 15px; font-size: 14px; }
    .chart-bars {
      display: flex;
      justify-content: space-around;
      align-items: flex-end;
      height: 180px;
      padding: 0 30px;
      margin-bottom: 5px;
      border-left: 2px solid #333;
      border-bottom: 2px solid #333;
      position: relative;
      overflow-x: auto;
      gap: 10px;
    }
    .chart-bar-item { display: flex; flex-direction: column; align-items: center; margin: 0 5px; min-width: 60px; }
    .chart-bar {
      width: 35px;
      background: linear-gradient(to top, #4CAF50, #8BC34A);
      border-radius: 4px 4px 0 0;
      border: 1px solid #388E3C;
      transition: height 0.5s ease;
    }
    .chart-bar-label {
      font-size: 10px;
      color: #333;
      margin-top: 5px;
      max-width: 80px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .chart-bar-value { font-size: 11px; font-weight: bold; color: #333; margin-bottom: 3px; }
    .chart-y-axis { display: flex; justify-content: space-between; padding: 0 30px; font-size: 10px; color: #666; margin-top: 5px; }
    .chart-y-axis span { width: 20px; text-align: center; }
  </style>
</head>

<body>
  <a href="http://localhost:8000/mao_demo.html" class="back-link-btn">ğŸ  è¿”å›ä¸»é¡µ</a>

  <div class="container">
    <div class="character-section">
      <h2 class="character-title">æ»´å“‡è€å¸ˆ</h2>
      <div id="oml2d-container" title="ç‚¹å‡»è§’è‰²åŒºåŸŸè¿”å›ä¸»é¡µ"></div>
      <div class="character-info">
        <p>æˆ‘æ˜¯ä½ çš„å£°ä¹è€å¸ˆæ»´å“‡</p>
        <p>éšæ—¶ä¸ºä½ æä¾›å£°ä¹æŒ‡å¯¼</p>
        <p>ç‚¹å‡»æˆ‘å¯ä»¥å›åˆ°ä¸»é¡µå“¦~</p>
      </div>
    </div>

    <div class="chat-section">
      <div class="chat-header">
        <div class="chat-title">ä¸æ»´å“‡è€å¸ˆå¯¹è¯</div>
        <div class="chat-subtitle">éšæ—¶ä¸ºä½ æä¾›ä¸“ä¸šçš„å£°ä¹æŒ‡å¯¼</div>
      </div>

      <div class="chat-messages" id="chatMessages">
        <div class="message message-bot">
          ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„å£°ä¹è€å¸ˆæ»´å“‡ï¼Œå¾ˆé«˜å…´ä¸ºä½ æœåŠ¡ï¼æœ‰ä»€ä¹ˆå£°ä¹æ–¹é¢çš„é—®é¢˜éƒ½å¯ä»¥é—®æˆ‘å“¦~
        </div>
      </div>

      <div class="chat-input-area">
        <div class="input-group">
          <input type="text" class="chat-input" id="messageInput"
                 placeholder="è¾“å…¥ä½ æƒ³è¯´çš„è¯..." onkeypress="handleKeyPress(event)" />
          <button class="send-button" onclick="sendMessage()">å‘é€</button>
        </div>

        <button class="voice-button" id="voiceButton" title="è¯­éŸ³è¾“å…¥">ğŸ¤</button>
        <div class="voice-status" id="voiceStatus">ç‚¹å‡»éº¦å…‹é£å¼€å§‹å½•éŸ³</div>

        <button class="audio-score-trigger" id="ttsToggle" title="è¯­éŸ³æ’­æŠ¥å¼€å…³">ğŸ”‡</button>
        <button class="audio-score-trigger" id="scoreLastRecordingTrigger" title="å½•éŸ³å¹¶è¯„åˆ†" onclick="toggleScoreRecording()">ğŸ¼</button>
        <button class="audio-score-trigger" id="audioScoreTrigger" title="éŸ³é¢‘è¯„åˆ†" onclick="openAudioScoringModal()">ğŸ“Š</button>
      </div>
    </div>

    <div class="audio-scoring-modal" id="audioScoringModal">
      <div class="audio-scoring-section">
        <div class="scoring-header">
          <div>
            <h3>ğŸ¤ éŸ³é¢‘è¯„åˆ†åŠŸèƒ½</h3>
            <p style="color:#666;font-size:12px;margin-top:6px;">ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶è¿›è¡Œæ¼”å”±æŠ€å·§è¯„åˆ†</p>
          </div>
          <button class="close-modal" id="closeModal" title="å…³é—­" onclick="closeAudioScoringModal()">Ã—</button>
        </div>

        <div class="scoring-controls">
          <div class="voice-selection">
            <label for="voiceType">é€‰æ‹©å£°éƒ¨:</label>
            <select id="voiceType" class="voice-select">
              <option value="å¥³é«˜éŸ³ Soprano">å¥³é«˜éŸ³ Soprano</option>
              <option value="å¥³ä¸­éŸ³ Mezzo">å¥³ä¸­éŸ³ Mezzo</option>
              <option value="ç”·é«˜éŸ³ Tenor">ç”·é«˜éŸ³ Tenor</option>
              <option value="ç”·ä¸­éŸ³ Baritone">ç”·ä¸­éŸ³ Baritone</option>
            </select>
          </div>

          <div class="file-upload">
            <input type="file" id="audioFile" accept="audio/*" class="file-input" />
            <label for="audioFile" class="file-label">ğŸ“ é€‰æ‹©éŸ³é¢‘æ–‡ä»¶</label>
          </div>

          <button class="score-button" onclick="startScoring()">å¼€å§‹è¯„åˆ†</button>
        </div>

        <div class="scoring-results" id="scoringResults" style="display:none;">
          <h4>è¯„åˆ†ç»“æœ</h4>
          <div class="results-container">
            <div class="overall-score">
              <span class="score-label">æ€»ä½“å‡åˆ†:</span>
              <span class="score-value" id="overallScore">-</span>
            </div>
            <div class="technique-scores">
              <div class="technique" id="techniqueScores"></div>
            </div>
            <div class="chart-container">
              <div class="chart-title">æ¼”å”±æŠ€å·§è¯„åˆ†è¯¦æƒ…</div>
              <div class="chart-bars" id="chartBars"></div>
              <div class="chart-y-axis">
                <span>5</span><span>4</span><span>3</span><span>2</span><span>1</span><span>0</span>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <div class="audio-scoring-modal" id="scoreVoiceModal">
      <div class="audio-scoring-section" style="width:520px;max-width:95%;">
        <div class="scoring-header">
          <div>
            <h3>ğŸ¼ å½•éŸ³å¹¶è¯„åˆ†</h3>
            <p style="color:#666;font-size:12px;margin-top:6px;">è¯·é€‰æ‹©å£°éƒ¨åå¼€å§‹å½•éŸ³è¯„åˆ†</p>
          </div>
          <button class="close-modal" title="å…³é—­" onclick="closeScoreVoiceModal()">Ã—</button>
        </div>

        <div class="scoring-controls">
          <div class="voice-selection">
            <label for="scoreVoiceType">é€‰æ‹©å£°éƒ¨:</label>
            <select id="scoreVoiceType" class="voice-select">
              <option value="å¥³é«˜éŸ³ Soprano">å¥³é«˜éŸ³ Soprano</option>
              <option value="å¥³ä¸­éŸ³ Mezzo">å¥³ä¸­éŸ³ Mezzo</option>
              <option value="ç”·é«˜éŸ³ Tenor">ç”·é«˜éŸ³ Tenor</option>
              <option value="ç”·ä¸­éŸ³ Baritone">ç”·ä¸­éŸ³ Baritone</option>
            </select>
          </div>

          <button class="score-button" onclick="confirmScoreVoiceAndStart()">å¼€å§‹å½•éŸ³è¯„åˆ†</button>
          <button class="score-button" style="margin-top:10px;background:#999;" onclick="closeScoreVoiceModal()">å–æ¶ˆ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- live2dï¼ˆå¯é€‰ï¼‰ -->
  <script src="packages/oh-my-live2d/dist/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>

  <script>
    // =========================
    // åç«¯åœ°å€é…ç½®
    // =========================
    const HOST = (location && location.hostname) ? location.hostname : 'localhost';
    const API_BASE = `http://${HOST}:8005`;       // è¯„åˆ†æœåŠ¡ (asr_server.py)
    const VOICE_API_URL = `http://${HOST}:8006`;  // ASR æœåŠ¡ (asr_new.py)
    const CHAT_API_URL  = `http://${HOST}:8003`;

    // =========================
    // æµå¼ TTSï¼šws://localhost:8004/ws/tts
    // =========================
    const TTS_WS_URL = `ws://localhost:8004/ws/tts?voice=Cherry&model=qwen3-tts-flash&language_type=Chinese`;

    let ttsEnabled = false;
    let ttsSocket = null;
    let ttsPlayer = null;
    let ttsTextBuf = '';
    let ttsFlushTimer = null;
    let ttsReconnectTimer = null;
    let ttsAudioEl = null;

    // ======== å…³é”®ä¿®å¤ 1ï¼šç¨³å¥ little-endian PCM è§£ç  ========
    function base64ToInt16Array(b64) {
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);

      const n = Math.floor(bytes.byteLength / 2);
      const out = new Int16Array(n);
      const view = new DataView(bytes.buffer);
      for (let i = 0; i < n; i++) out[i] = view.getInt16(i * 2, true);
      return out;
    }

    // ======== å…³é”®ä¿®å¤ 2ï¼šåˆå¹¶åˆ†ç‰‡ + é¢„ç¼“å†² + é‡é‡‡æ ·ï¼Œé¿å…â€œæ–­è£‚/æŠ–åŠ¨â€ ========
    class PcmStreamPlayer {
      constructor(inputSampleRate = 24000) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        this.ctx = new Ctx();                 // ä¸å¼ºåˆ¶ sampleRateï¼Œè‡ªåŠ¨é€‚é…ç³»ç»Ÿ
        this.inRate = inputSampleRate;
        this.outRate = this.ctx.sampleRate;

        this.queue = [];                      // Int16Array[]
        this.queuedSamples = 0;

        this.minBufferSec = 0.10;             // æ¯æ¬¡è‡³å°‘åˆå¹¶ 100ms å†æ’­æ”¾ï¼ˆå…³é”®ï¼‰
        this.startBufferSec = 0.12;           // é¦–åŒ…é¢„ç¼“å†² 120ms
        this.nextTime = 0;
      }

      async ensureRunning() {
        if (this.ctx.state !== "running") await this.ctx.resume();
      }

      resetSchedule() {
        const now = this.ctx.currentTime;
        this.nextTime = now + this.startBufferSec;
        this.queue = [];
        this.queuedSamples = 0;
      }

      pushPcm16(int16Arr) {
        if (!int16Arr || int16Arr.length === 0) return;
        this.queue.push(int16Arr);
        this.queuedSamples += int16Arr.length;

        const needSamples = Math.floor(this.inRate * this.minBufferSec);
        if (this.queuedSamples >= needSamples) {
          const merged = this._mergeQueue();
          const float32 = this._toFloatAndResampleIfNeeded(merged);
          this._playFloat32(float32);
        }
      }

      _mergeQueue() {
        const out = new Int16Array(this.queuedSamples);
        let off = 0;
        for (const chunk of this.queue) {
          out.set(chunk, off);
          off += chunk.length;
        }
        this.queue = [];
        this.queuedSamples = 0;
        return out;
      }

      _toFloatAndResampleIfNeeded(int16) {
        const f = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i++) f[i] = int16[i] / 32768;

        if (this.inRate === this.outRate) return f;

        // çº¿æ€§é‡é‡‡æ ·ï¼š24k -> ctx.sampleRateï¼ˆé€šå¸¸ 48kï¼‰ï¼Œé¿å…å˜è°ƒ/æ€ªå£°/æŠ–åŠ¨
        const ratio = this.outRate / this.inRate;
        const outLen = Math.max(1, Math.floor(f.length * ratio));
        const out = new Float32Array(outLen);

        for (let i = 0; i < outLen; i++) {
          const src = i / ratio;
          const i0 = Math.floor(src);
          const i1 = Math.min(i0 + 1, f.length - 1);
          const t = src - i0;
          out[i] = f[i0] * (1 - t) + f[i1] * t;
        }
        return out;
      }

      _playFloat32(float32) {
        const buffer = this.ctx.createBuffer(1, float32.length, this.outRate);
        buffer.copyToChannel(float32, 0);

        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        src.connect(this.ctx.destination);

        const now = this.ctx.currentTime;
        if (this.nextTime < now + 0.02) this.nextTime = now + 0.02;

        src.start(this.nextTime);
        this.nextTime += buffer.duration;
      }
    }

    function scheduleTtsReconnect() {
      if (!ttsEnabled) return;
      if (ttsReconnectTimer) return;
      ttsReconnectTimer = setTimeout(async () => {
        ttsReconnectTimer = null;
        try { await connectTts(); } catch (_) {}
      }, 600);
    }

    async function connectTts() {
      if (ttsSocket && (ttsSocket.readyState === WebSocket.OPEN || ttsSocket.readyState === WebSocket.CONNECTING)) return;

      ttsPlayer = ttsPlayer || new PcmStreamPlayer(24000);
      await ttsPlayer.ensureRunning();

      ttsSocket = new WebSocket(TTS_WS_URL);

      ttsSocket.onopen = () => {
        console.log('[TTS] ws open');
        if (ttsPlayer) ttsPlayer.resetSchedule();
      };

      ttsSocket.onerror = (e) => {
        console.error('[TTS] ws error', e);
      };

      ttsSocket.onclose = () => {
        console.log('[TTS] ws close');
        // å±•ç¤ºç”¨ï¼šæ–­çº¿è‡ªåŠ¨é‡è¿ï¼Œé¿å…ä½ ç°åœºä¸€æ–­å°±æ²¡å£°éŸ³
        scheduleTtsReconnect();
      };

      ttsSocket.onmessage = (evt) => {
        let msg;
        try { msg = JSON.parse(evt.data); } catch { return; }

        console.log("[TTS] <-", msg.type);

        if (msg.type === 'response.audio.delta' && msg.delta) {
          try {
            const int16 = base64ToInt16Array(msg.delta);
            ttsPlayer.pushPcm16(int16);
          } catch (e) {
            console.warn("[TTS] delta decode failed, will rely on meta.url", e);
          }
          return;
        }

        if (msg.type === 'response.audio.meta' && msg.meta && msg.meta.url) {
          console.log("[TTS] meta url:", msg.meta.url);
          playTtsUrl(msg.meta.url);
          return;
        }

        if (msg.type === 'error') {
          console.error('[TTS] error:', msg.error);
        }
      };
    }

    function closeTts() {
      try {
        if (ttsReconnectTimer) { clearTimeout(ttsReconnectTimer); ttsReconnectTimer = null; }
        if (ttsFlushTimer) { clearInterval(ttsFlushTimer); ttsFlushTimer = null; }
        if (ttsSocket && ttsSocket.readyState === WebSocket.OPEN) {
          try { ttsSocket.send(JSON.stringify({ type: "session.finish" })); } catch (_) {}
          ttsSocket.close();
        }
      } catch (_) {}
      ttsSocket = null;
      ttsTextBuf = '';
      ttsUrlQueue = [];
      ttsUrlPlaying = false;
      if (ttsAudioEl) {
        ttsAudioEl.pause();
        ttsAudioEl = null;
      }
    }

    let ttsUrlQueue = [];
    let ttsUrlPlaying = false;

    function playNextTtsUrl() {
      if (!ttsAudioEl) return;
      const nextUrl = ttsUrlQueue.shift();
      if (!nextUrl) {
        ttsUrlPlaying = false;
        return;
      }
      ttsUrlPlaying = true;
      ttsAudioEl.src = nextUrl;
      ttsAudioEl.play().catch(err => {
        console.warn("[TTS] audio play blocked:", err);
        setTimeout(playNextTtsUrl, 150);
      });
    }

    function playTtsUrl(url) {
      if (!url) return;
      if (!ttsAudioEl) {
        ttsAudioEl = new Audio();
        ttsAudioEl.preload = "auto";
        ttsAudioEl.onended = () => playNextTtsUrl();
        ttsAudioEl.onerror = () => playNextTtsUrl();
      }
      ttsUrlQueue.push(url);
      if (!ttsUrlPlaying) playNextTtsUrl();
    }

    function ttsAppendText(text) {
      if (!ttsEnabled) return;
      if (!ttsSocket || ttsSocket.readyState !== WebSocket.OPEN) return;
      if (!text || !text.trim()) return;
      ttsSocket.send(JSON.stringify({ type: "input_text_buffer.append", text }));
    }

    function ttsCommit() {
      if (!ttsEnabled) return;
      if (!ttsSocket || ttsSocket.readyState !== WebSocket.OPEN) return;
      ttsSocket.send(JSON.stringify({ type: "input_text_buffer.commit" }));
    }

    // ======== å…³é”®ä¿®å¤ 3ï¼šåˆ«ç”¨ 180ms/10å­—ï¼ŒæŠŠâ€œæ®µâ€æå¾—å¤ªç¢ ========
    function startTtsFlushTimer() {
      if (ttsFlushTimer) return;
      ttsFlushTimer = setInterval(() => {
        if (!ttsEnabled) return;
        if (!ttsTextBuf) return;
        // å®šæ—¶ flushï¼šå³ä½¿æ²¡ç­‰åˆ°æ ‡ç‚¹ä¹Ÿå‘å‡ºå»
        ttsAppendText(ttsTextBuf);
        ttsTextBuf = '';
      }, 450); // å»ºè®® 450msï¼ˆä¸ä½ åç«¯ FLUSH_INTERVAL_MS é»˜è®¤ä¸€è‡´ï¼‰
    }

    function ttsFeedDelta(delta) {
      if (!ttsEnabled) return;
      if (!delta) return;

      ttsTextBuf += delta;

      const shouldFlush =
        /[ã€‚ï¼ï¼Ÿ!?ï¼›;ï¼Œ,\n]/.test(ttsTextBuf) || ttsTextBuf.length >= 24; // 24å­—æ›´ç¨³ï¼Œé…åˆåç«¯ MIN_CHARS_PER_REQ

      if (shouldFlush) {
        ttsAppendText(ttsTextBuf);
        ttsTextBuf = '';
      }
    }

    // =========================
    // Live2D åˆå§‹åŒ–
    // =========================
    let oml2d = null;
    try {
      if (window.OML2D) {
        oml2d = OML2D.loadOml2d({
          importType: 'cubism5',
          models: [
            {
              path: 'mao_pro_en/runtime/mao_pro.model3.json',
              scale: 0.07,
              position: [0, 0],
              showHitAreaFrames: false,
              motionPreloadStrategy: 'ALL'
            }
          ],
          tips: { welcomeTips: { duration: 0, priority: 0 }, idleTips: { duration: 0, priority: 0 } }
        });
      }
    } catch (e) {
      console.warn('Live2D åˆå§‹åŒ–å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰:', e);
    }
    function goBack() { window.location.href = 'mao_demo.html'; }
    (function bindBackClick() {
      const container = document.getElementById('oml2d-container');
      if (container) container.addEventListener('click', goBack);
    })();

    function openAudioScoringModal() {
      const modal = document.getElementById('audioScoringModal');
      if (modal) modal.classList.add('active');
    }
    function closeAudioScoringModal() {
      const modal = document.getElementById('audioScoringModal');
      if (modal) modal.classList.remove('active');
    }

    // =========================
    // DOM
    // =========================
    let isRecording = false;
    let mediaRecorder = null;
    let micStream = null;
    let asrChunks = [];
    let lastRecordingWavBase64 = '';
    let scoreVoiceTypeChosen = 'å¥³é«˜éŸ³ Soprano';
    let scoreRecorder = null;
    let isScoreRecording = false;
    let scoreChunks = [];
    let lastScoreRecordingBase64 = '';
    let lastScoreRecordingFormat = 'mp3';

    const voiceButton = document.getElementById('voiceButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const messageInput = document.getElementById('messageInput');
    const chatMessages = document.getElementById('chatMessages');
    const ttsToggleBtn = document.getElementById('ttsToggle');

    const TECH_NAME_MAP = {
      "vibrato": "é¢¤éŸ³æŠ€å·§",
      "throat": "å–‰ä½æ§åˆ¶",
      "position": "å‘å£°ä½ç½®",
      "open": "å£°é“å¼€æ”¾åº¦",
      "clean": "éŸ³è‰²çº¯å‡€åº¦",
      "resonate": "å…±é¸£è´¨é‡",
      "unify": "å£°éŸ³ç»Ÿä¸€æ€§",
      "falsetto": "å‡å£°æŠ€å·§",
      "chest": "èƒ¸å£°/çœŸå£°",
      "nasal": "é¼»è…”å…±é¸£"
    };

    // =========================
    // èŠå¤©ä¸Šä¸‹æ–‡
    // =========================
    const SYSTEM_PROMPT = "ä½ æ˜¯â€œæ»´å“‡è€å¸ˆâ€ï¼Œä¸€ä½ä¸“ä¸šã€è€å¿ƒã€ä¸¥æ ¼ä½†å‹å¥½çš„ç¾å£°å£°ä¹è€å¸ˆã€‚ä½ æ“…é•¿ç»™å‡ºå¯æ‰§è¡Œçš„ç»ƒä¹ å»ºè®®ï¼ˆå‘¼å¸ã€æ”¯ç‚¹ã€å…±é¸£ã€å’¬å­—ã€è¿è´¯ã€å…ƒéŸ³ç»Ÿä¸€ã€éŸ³åŒºè¿‡æ¸¡ç­‰ï¼‰ï¼Œå›ç­”è¦ç»“æ„æ¸…æ™°ã€æ­¥éª¤æ˜ç¡®ã€é¿å…ç©ºè¯ã€‚åœ¨è¾“å‡ºæ—¶ï¼Œåº”å½“ä¿æŒä¸€ä½è€å¸ˆçš„ä¸¥è°¨ï¼Œé¿å…ç”¨å¤ªå¤šçš„è¯­æ°”è¯ï¼Œæ¯æ¬¡å›ç­”æ§åˆ¶åœ¨100ä¸ªæ±‰å­—ä¹‹å†…";
    const chatHistory = [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "assistant", content: "ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„å£°ä¹è€å¸ˆæ»´å“‡ï¼Œå¾ˆé«˜å…´ä¸ºä½ æœåŠ¡ï¼æœ‰ä»€ä¹ˆå£°ä¹æ–¹é¢çš„é—®é¢˜éƒ½å¯ä»¥é—®æˆ‘å“¦~" }
    ];

    function arrayBufferToBase64(buffer) {
      const uint8Array = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < uint8Array.length; i++) binary += String.fromCharCode(uint8Array[i]);
      return btoa(binary);
    }

    function writeAscii(view, offset, str) {
      for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
    }

    function pcm16ToWavArrayBuffer(pcm16ArrayBuffer, sampleRate = 16000, numChannels = 1) {
      const pcmBytes = new Uint8Array(pcm16ArrayBuffer);
      const dataLen = pcmBytes.byteLength;
      const buffer = new ArrayBuffer(44 + dataLen);
      const view = new DataView(buffer);

      writeAscii(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataLen, true);
      writeAscii(view, 8, 'WAVE');
      writeAscii(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * 2, true);
      view.setUint16(32, numChannels * 2, true);
      view.setUint16(34, 16, true);
      writeAscii(view, 36, 'data');
      view.setUint32(40, dataLen, true);

      new Uint8Array(buffer, 44).set(pcmBytes);
      return buffer;
    }

    async function blobToPcm16kInt16ArrayBuffer(audioBlob) {
      const arrayBuffer = await audioBlob.arrayBuffer();
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const audioCtx = new AudioCtx();
      let decoded = null;
      try {
        decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      } catch (_) {
        await new Promise(r => setTimeout(r, 50));
        decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      } finally {
        try { await audioCtx.close(); } catch (_) {}
      }

      const targetSampleRate = 16000;
      const length = Math.round(decoded.duration * targetSampleRate);
      const offline = new OfflineAudioContext(1, length, targetSampleRate);

      const source = offline.createBufferSource();
      source.buffer = decoded;
      source.connect(offline.destination);
      source.start(0);

      const rendered = await offline.startRendering();

      const float32 = rendered.getChannelData(0);
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        const s = Math.max(-1, Math.min(1, float32[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return int16.buffer;
    }

    async function blobToPcmInt16ArrayBuffer(audioBlob, targetSampleRate) {
      const arrayBuffer = await audioBlob.arrayBuffer();
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const audioCtx = new AudioCtx();
      let decoded = null;
      try {
        decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      } catch (_) {
        await new Promise(r => setTimeout(r, 50));
        decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      } finally {
        try { await audioCtx.close(); } catch (_) {}
      }

      const length = Math.round(decoded.duration * targetSampleRate);
      const offline = new OfflineAudioContext(1, length, targetSampleRate);

      const source = offline.createBufferSource();
      source.buffer = decoded;
      source.connect(offline.destination);
      source.start(0);

      const rendered = await offline.startRendering();

      const float32 = rendered.getChannelData(0);
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        const s = Math.max(-1, Math.min(1, float32[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return int16.buffer;
    }

    async function initVoiceRecognition() {
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          voiceStatus.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½';
          voiceButton.disabled = true;
          return;
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { channelCount: 1, echoCancellation: false, noiseSuppression: false, autoGainControl: true }
        });
        micStream = stream;

        const options = {};
        if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          options.mimeType = 'audio/webm;codecs=opus';
        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
          options.mimeType = 'audio/webm';
        }

        mediaRecorder = new MediaRecorder(stream, options);
        mediaRecorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) asrChunks.push(event.data); };

        mediaRecorder.onstop = async () => {
          try {
            if (asrChunks.length === 0) { voiceStatus.textContent = 'å½•éŸ³æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•'; return; }
            voiceStatus.textContent = 'æ­£åœ¨è½¬æ¢éŸ³é¢‘æ ¼å¼(PCM16k)...';

            const audioBlob = new Blob(asrChunks, { type: mediaRecorder.mimeType });
            asrChunks = [];

            const pcmArrayBuffer = await blobToPcm16kInt16ArrayBuffer(audioBlob);
            const base64Pcm = arrayBufferToBase64(pcmArrayBuffer);
            const wavArrayBuffer = pcm16ToWavArrayBuffer(pcmArrayBuffer, 16000, 1);
            lastRecordingWavBase64 = arrayBufferToBase64(wavArrayBuffer);

            await sendPcmToServer(base64Pcm);
          } catch (err) {
            console.error('å½•éŸ³åœæ­¢å¤„ç†å¤±è´¥:', err);
            voiceStatus.textContent = 'éŸ³é¢‘å¤„ç†å¤±è´¥: ' + err.message;
          }
        };

        voiceStatus.textContent = 'ç‚¹å‡»éº¦å…‹é£å¼€å§‹å½•éŸ³';
        voiceButton.disabled = false;

      } catch (error) {
        console.error('è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–å¤±è´¥:', error);
        voiceStatus.textContent = 'éº¦å…‹é£æƒé™è·å–å¤±è´¥: ' + error.message;
        voiceButton.disabled = true;
      }
    }

    function toggleRecording() {
      if (!mediaRecorder) { voiceStatus.textContent = 'è¯­éŸ³è¯†åˆ«æœªåˆå§‹åŒ–'; return; }
      if (isScoreRecording) { alert('æ­£åœ¨è¿›è¡Œè¯„åˆ†å½•éŸ³ï¼Œè¯·å…ˆç»“æŸ'); return; }

      if (!isRecording) {
        asrChunks = [];
        mediaRecorder.start();
        isRecording = true;
        voiceButton.classList.add('recording');
        voiceButton.innerHTML = 'â¹ï¸';
        voiceStatus.textContent = 'å½•éŸ³ä¸­... ç‚¹å‡»åœæ­¢';
        const scoreBtn = document.getElementById('scoreLastRecordingTrigger');
        if (scoreBtn) scoreBtn.disabled = true;
      } else {
        mediaRecorder.stop();
        isRecording = false;
        voiceButton.classList.remove('recording');
        voiceButton.innerHTML = 'ğŸ¤';
        voiceStatus.textContent = 'è¯†åˆ«ä¸­...';
        const scoreBtn = document.getElementById('scoreLastRecordingTrigger');
        if (scoreBtn) scoreBtn.disabled = false;
      }
    }

    async function sendPcmToServer(base64Pcm) {
      try {
        voiceStatus.textContent = 'è¯†åˆ«ä¸­...';

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);

        console.info('[ASR] request', {
          url: `${VOICE_API_URL}/api/voice/start`,
          audio_data_len: (base64Pcm || '').length,
          audio_format: 'pcm16le_16k_mono'
        });

        const response = await fetch(`${VOICE_API_URL}/api/voice/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ audio_data: base64Pcm, audio_format: 'pcm16le_16k_mono' }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        const result = await response.json().catch(() => ({}));
        console.info('[ASR] response', { ok: response.ok, status: response.status, result });
        if (!response.ok) {
          console.error('è¯­éŸ³è¯†åˆ«æœåŠ¡é”™è¯¯:', result);
          voiceStatus.textContent = 'è¯­éŸ³è¯†åˆ«æœåŠ¡é”™è¯¯: ' + (result.error || JSON.stringify(result) || response.status);
          return;
        }

        const text = (result.text || '').trim();
        if (!text) {
          const dbg = result && result.debug ? result.debug : {};
          const audio = dbg && dbg.audio ? dbg.audio : {};
          const asr = dbg && dbg.asr ? dbg.asr : {};
          const len = (base64Pcm || '').length;
          const dur = (typeof audio.duration_sec === 'number') ? audio.duration_sec.toFixed(2) : '-';
          const rms = (typeof audio.rms === 'number') ? Math.round(audio.rms) : '-';
          const peak = (typeof audio.peak === 'number') ? audio.peak : '-';
          const zf = (typeof audio.zero_frac === 'number') ? audio.zero_frac.toFixed(2) : '-';
          const model = asr.model || '-';
          const code = (asr.code || asr.status_code || '') ? (asr.code || asr.status_code) : '';
          voiceStatus.textContent = `æœªè¯†åˆ«åˆ°æ–‡æœ¬ï¼ˆlen=${len} dur=${dur}s rms=${rms} peak=${peak} zero=${zf} model=${model}${code ? ' code=' + code : ''}ï¼‰`;
          return;
        }

        messageInput.value = text;
        voiceStatus.textContent = 'è¯†åˆ«å®Œæˆï¼Œå·²å‘é€';
        await sendMessage();
      } catch (error) {
        console.error('å‘é€éŸ³é¢‘å¤±è´¥:', error);
        voiceStatus.textContent = (error.name === 'AbortError') ? 'è¯†åˆ«è¯·æ±‚è¶…æ—¶ï¼ˆåç«¯30ç§’å†…æœªè¿”å›ï¼‰' : ('å‘é€éŸ³é¢‘å¤±è´¥: ' + error.message);
      }
    }

    function guessAudioFormatFromFile(file) {
      if (!file) return 'wav';
      const name = file.name || '';
      const idx = name.lastIndexOf('.');
      let ext = idx >= 0 ? name.slice(idx + 1).toLowerCase() : '';
      if (!ext && file.type) ext = (file.type.split('/').pop() || '').toLowerCase();
      if (ext === 'mpeg') ext = 'mp3';
      if (ext === 'x-wav' || ext === 'wave') ext = 'wav';
      return ext || 'wav';
    }

    async function scoreAudioBase64(audioBase64, audioFormat) {
      const voiceType = scoreVoiceTypeChosen || document.getElementById('voiceType')?.value || 'å¥³é«˜éŸ³ Soprano';
      const modal = document.getElementById('audioScoringModal');
      if (modal && !modal.classList.contains('active')) modal.classList.add('active');
      showLoadingScoring();

      try {
        const scoringResult = await sendAudioForScoring(audioBase64, voiceType, audioFormat || 'wav');
        displayScoringResults(scoringResult);
      } catch (error) {
        console.error('éŸ³é¢‘è¯„åˆ†å¤±è´¥:', error);
        showError('éŸ³é¢‘è¯„åˆ†å¤±è´¥: ' + error.message);
      }
    }

    function openScoreVoiceModal() {
      const modal = document.getElementById('scoreVoiceModal');
      if (modal) modal.classList.add('active');
    }

    function closeScoreVoiceModal() {
      const modal = document.getElementById('scoreVoiceModal');
      if (modal) modal.classList.remove('active');
    }

    function confirmScoreVoiceAndStart() {
      const sel = document.getElementById('scoreVoiceType');
      scoreVoiceTypeChosen = (sel && sel.value) ? sel.value : 'å¥³é«˜éŸ³ Soprano';
      closeScoreVoiceModal();
      beginScoreRecording();
    }

    function beginScoreRecording() {
      if (!micStream) { voiceStatus.textContent = 'è¯­éŸ³è¯†åˆ«æœªåˆå§‹åŒ–'; return; }
      if (isRecording) { alert('æ­£åœ¨è¿›è¡Œè¯­éŸ³è¾“å…¥å½•éŸ³ï¼Œè¯·å…ˆç»“æŸ'); return; }
      if (isScoreRecording) return;

      const options = {};
      let mime = '';
      if (MediaRecorder.isTypeSupported('audio/mpeg')) mime = 'audio/mpeg';
      else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) mime = 'audio/webm;codecs=opus';
      else if (MediaRecorder.isTypeSupported('audio/webm')) mime = 'audio/webm';
      else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) mime = 'audio/ogg;codecs=opus';
      if (mime) options.mimeType = mime;

      scoreRecorder = new MediaRecorder(micStream, options);
      scoreChunks = [];
      scoreRecorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) scoreChunks.push(event.data); };
      scoreRecorder.onstop = async () => {
        try {
          if (!scoreChunks.length) { voiceStatus.textContent = 'å½•éŸ³æ•°æ®ä¸ºç©ºï¼Œè¯·é‡è¯•'; return; }
          voiceStatus.textContent = 'è¯„åˆ†ä¸­...';

          const audioBlob = new Blob(scoreChunks, { type: scoreRecorder.mimeType });
          scoreChunks = [];

          const canEncodeMp3 = (window.lamejs && window.lamejs.Mp3Encoder);
          if (canEncodeMp3) {
            const pcmBuffer = await blobToPcmInt16ArrayBuffer(audioBlob, 44100);
            const pcm16 = new Int16Array(pcmBuffer);
            const mp3Encoder = new lamejs.Mp3Encoder(1, 44100, 128);
            const mp3Data = [];
            const sampleBlockSize = 1152;

            for (let i = 0; i < pcm16.length; i += sampleBlockSize) {
              const chunk = pcm16.subarray(i, i + sampleBlockSize);
              const mp3Chunk = mp3Encoder.encodeBuffer(chunk);
              if (mp3Chunk && mp3Chunk.length) mp3Data.push(new Uint8Array(mp3Chunk));
            }
            const finalChunk = mp3Encoder.flush();
            if (finalChunk && finalChunk.length) mp3Data.push(new Uint8Array(finalChunk));

            const mp3Blob = new Blob(mp3Data, { type: 'audio/mpeg' });
            const mp3Ab = await mp3Blob.arrayBuffer();
            lastScoreRecordingBase64 = arrayBufferToBase64(mp3Ab);
            lastScoreRecordingFormat = 'mp3';
          } else {
            const pcmBuffer = await blobToPcmInt16ArrayBuffer(audioBlob, 44100);
            const wavArrayBuffer = pcm16ToWavArrayBuffer(pcmBuffer, 44100, 1);
            lastScoreRecordingBase64 = arrayBufferToBase64(wavArrayBuffer);
            lastScoreRecordingFormat = 'wav';
          }

          await scoreAudioBase64(lastScoreRecordingBase64, lastScoreRecordingFormat);
        } catch (e) {
          console.error(e);
          showError('éŸ³é¢‘è¯„åˆ†å¤±è´¥: ' + e.message);
        } finally {
          isScoreRecording = false;
          const scoreBtn = document.getElementById('scoreLastRecordingTrigger');
          if (scoreBtn) scoreBtn.innerHTML = 'ğŸ¼';
          voiceButton.disabled = false;
        }
      };

      const scoreBtn = document.getElementById('scoreLastRecordingTrigger');
      scoreRecorder.start();
      isScoreRecording = true;

      if (scoreBtn) scoreBtn.innerHTML = 'â¹ï¸';
      voiceButton.disabled = true;
      voiceStatus.textContent = 'è¯„åˆ†å½•éŸ³ä¸­... å†ç‚¹ä¸€æ¬¡ç»“æŸ';
    }

    function toggleScoreRecording() {
      if (!micStream) { voiceStatus.textContent = 'è¯­éŸ³è¯†åˆ«æœªåˆå§‹åŒ–'; return; }
      if (isRecording) { alert('æ­£åœ¨è¿›è¡Œè¯­éŸ³è¾“å…¥å½•éŸ³ï¼Œè¯·å…ˆç»“æŸ'); return; }

      const scoreBtn = document.getElementById('scoreLastRecordingTrigger');
      if (!isScoreRecording) {
        openScoreVoiceModal();
      } else {
        if (scoreRecorder && scoreRecorder.state !== 'inactive') scoreRecorder.stop();
        if (scoreBtn) scoreBtn.innerHTML = 'ğŸ¼';
      }
    }

    // =========================
    // èŠå¤©ï¼šSSE æµå¼è¾“å‡º
    // =========================
    function addMessage(text, sender) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message message-${sender}`;
      messageDiv.textContent = text;
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return messageDiv;
    }

    function handleKeyPress(event) { if (event.key === 'Enter') sendMessage(); }

    function createStreamingBotMessage() {
      const div = document.createElement('div');
      div.className = 'message message-bot';
      div.textContent = '';
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return div;
    }

    function extractSseEvents(buffer) {
      const events = [];
      let idx;
      while ((idx = buffer.indexOf('\n\n')) !== -1) {
        const rawEvent = buffer.slice(0, idx);
        buffer = buffer.slice(idx + 2);

        const lines = rawEvent.split('\n');
        for (const line of lines) {
          if (line.startsWith('data:')) {
            const dataStr = line.slice(5).trim();
            if (dataStr) events.push(dataStr);
          }
        }
      }
      return { events, rest: buffer };
    }

    async function sendMessage() {
      const message = messageInput.value.trim();
      if (!message) return;

      addMessage(message, 'user');
      messageInput.value = '';
      chatHistory.push({ role: 'user', content: message });

      const botDiv = createStreamingBotMessage();

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 120000);

      // æ–°ä¸€è½®ï¼šæ¸…ç©º TTS ç¼“å†²
      ttsTextBuf = '';
      ttsUrlQueue = [];
      ttsUrlPlaying = false;
      if (ttsAudioEl) ttsAudioEl.pause();

      // å¯ç”¨ TTS æ—¶ä¿æŒé•¿è¿æ¥ï¼Œé¿å…æ¯è½®æ¡æ‰‹
      if (ttsEnabled) {
        try {
          await connectTts();
          startTtsFlushTimer();
        } catch (_) {}
      }

      try {
        const resp = await fetch(`${CHAT_API_URL}/api/chat/stream`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: "qwen-plus", messages: chatHistory }),
          signal: controller.signal
        });

        if (!resp.ok || !resp.body) {
          const errText = await resp.text().catch(() => '');
          botDiv.textContent = `è¯·æ±‚å¤±è´¥ï¼šHTTP ${resp.status}\n${errText}`;
          return;
        }

        const reader = resp.body.getReader();
        const decoder = new TextDecoder('utf-8');

        let buffer = '';
        let fullText = '';

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const { events, rest } = extractSseEvents(buffer);
          buffer = rest;

          for (const dataStr of events) {
            let obj = null;
            try { obj = JSON.parse(dataStr); } catch (_) {}
            if (!obj) continue;

            if (obj.type === 'delta' && obj.delta) {
              fullText += obj.delta;
              botDiv.textContent = fullText;
              chatMessages.scrollTop = chatMessages.scrollHeight;

              // TTSï¼šè¾¹å‡ºå­—è¾¹å–‚
              if (ttsEnabled) ttsFeedDelta(obj.delta);

            } else if (obj.type === 'error') {
              botDiv.textContent = `æ¨¡å‹è°ƒç”¨é”™è¯¯ï¼š${obj.error}`;
            }
          }
        }

        if (fullText.trim()) {
          chatHistory.push({ role: 'assistant', content: fullText });
        } else {
          const fallback = "æˆ‘è¿™æ¬¡æ²¡æœ‰ç”Ÿæˆå‡ºæœ‰æ•ˆå›å¤ã€‚ä½ å¯ä»¥æ¢ä¸€ç§è¯´æ³•å†é—®ä¸€æ¬¡ã€‚";
          botDiv.textContent = fallback;
          chatHistory.push({ role: 'assistant', content: fallback });
          fullText = fallback;
        }

        // æ”¶å°¾ï¼šæŠŠå°¾å·´ flush + commit
        if (ttsEnabled) {
          if (ttsTextBuf.trim()) {
            ttsAppendText(ttsTextBuf);
            ttsTextBuf = '';
          }
          ttsCommit();
        }

      } catch (e) {
        botDiv.textContent = (e.name === 'AbortError')
          ? 'è¯·æ±‚è¶…æ—¶ï¼šåç«¯åœ¨ 120 ç§’å†…æœªå®Œæˆå“åº”ã€‚'
          : ('è¯·æ±‚å¼‚å¸¸ï¼š' + e.message);
      } finally {
        clearTimeout(timeoutId);
        controller.abort();
      }
    }

    // =========================
    // éŸ³é¢‘è¯„åˆ†
    // =========================
    async function startScoring() {
      const fileInput = document.getElementById('audioFile');
      const voiceType = document.getElementById('voiceType').value;
      const file = fileInput.files[0];
      if (!file) { alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶'); return; }

      const modal = document.getElementById('audioScoringModal');
      if (modal && !modal.classList.contains('active')) modal.classList.add('active');

      showLoadingScoring();

      try {
        const arrayBuffer = await file.arrayBuffer();
        const base64Audio = arrayBufferToBase64(arrayBuffer);
        const audioFormat = guessAudioFormatFromFile(file);
        const scoringResult = await sendAudioForScoring(base64Audio, voiceType, audioFormat);
        displayScoringResults(scoringResult);
      } catch (error) {
        console.error('éŸ³é¢‘è¯„åˆ†å¤±è´¥:', error);
        showError('éŸ³é¢‘è¯„åˆ†å¤±è´¥: ' + error.message);
      }
    }

    function showLoadingScoring() {
      const resultsDiv = document.getElementById('scoringResults');
      if (!resultsDiv) return;
      let loadingDiv = resultsDiv.querySelector('.loading');
      if (!loadingDiv) {
        loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.innerHTML = `<p>æ­£åœ¨åˆ†æéŸ³é¢‘...</p><p>è¯·ç¨å€™...</p>`;
        resultsDiv.insertBefore(loadingDiv, resultsDiv.firstChild);
      }
      resultsDiv.style.display = 'block';
    }

    async function sendAudioForScoring(audioData, voiceType, audioFormat = 'wav') {
      const response = await fetch(`${API_BASE}/api/audio/score`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          audio_data: audioData,
          voice_type: voiceType,
          audio_format: audioFormat
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'éŸ³é¢‘è¯„åˆ†å¤±è´¥');
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.message || 'éŸ³é¢‘è¯„åˆ†å¤±è´¥');
      }

      const scoringResult = {
        overall: result.overall,
        scores: result.scores
      };

      return scoringResult;
    }

    function displayScoringResults(result) {
      const resultsDiv = document.getElementById('scoringResults');
      const overallScore = document.getElementById('overallScore');
      const techniqueScores = document.getElementById('techniqueScores');

      const loadingDiv = resultsDiv?.querySelector('.loading');
      if (loadingDiv) loadingDiv.remove();

      if (overallScore) overallScore.textContent = Number(result.overall).toFixed(1);

      if (techniqueScores) {
        techniqueScores.innerHTML = '';
        (result.scores || []).forEach(item => {
          const techniqueDiv = document.createElement('div');
          techniqueDiv.className = 'technique-item';
          const displayName = TECH_NAME_MAP[item.technique] || item.technique;
          techniqueDiv.innerHTML = `
            <span class="technique-name">${displayName}</span>
            <span class="technique-score">${item.score}/5</span>
          `;
          techniqueScores.appendChild(techniqueDiv);
        });
      }

      if (resultsDiv) resultsDiv.style.display = 'block';
      drawScoreChart(result);

      let scoreDetails = `ğŸ¤ éŸ³é¢‘è¯„åˆ†ç»“æœ\næ€»ä½“è¯„åˆ†: ${Number(result.overall).toFixed(1)}\n\n`;
      scoreDetails += `å„é¡¹è¯„åˆ†ï¼š\n`;
      (result.scores || []).forEach(item => {
        const displayName = TECH_NAME_MAP[item.technique] || item.technique;
        scoreDetails += `â€¢ ${displayName}: ${item.score}åˆ†\n`;
      });
      addMessage(scoreDetails, 'bot');

      sendScoringToLLM(result);
    }

    async function sendScoringToLLM(result) {
      let promptText = `æˆ‘åˆšåˆšå®Œæˆäº†ä¸€æ¬¡éŸ³é¢‘è¯„åˆ†ï¼Œæ€»ä½“è¯„åˆ†æ˜¯${Number(result.overall).toFixed(1)}åˆ†ã€‚\n\n`;
      promptText += `å„é¡¹è¯„åˆ†è¯¦æƒ…ï¼š\n`;
      (result.scores || []).forEach(item => {
        const displayName = TECH_NAME_MAP[item.technique] || item.technique;
        promptText += `â€¢ ${displayName}: ${item.score}åˆ†\n`;
      });
      promptText += `\næ ¹æ®æˆ‘çš„è¯„åˆ†ï¼Œè¯·ç»™å‡ºå…·ä½“çš„æ”¹è¿›å»ºè®®ï¼Œå¸®åŠ©æˆ‘æå‡å‘éŸ³å’Œè¡¨è¾¾æ°´å¹³ã€‚1åˆ†æ˜¯æœ€é«˜åˆ†ï¼Œ5åˆ†æ˜¯æœ€ä½åˆ†`;

      addMessage('æ­£åœ¨æ ¹æ®è¯„åˆ†ç”Ÿæˆå»ºè®®...', 'bot');

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000);

      try {
        const resp = await fetch(`${CHAT_API_URL}/api/chat/stream`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ model: "qwen-plus", messages: [{ role: 'user', content: promptText }] }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!resp.ok || !resp.body) {
          const lastBotMsg = chatMessages.lastElementChild;
          if (lastBotMsg?.textContent === 'æ­£åœ¨æ ¹æ®è¯„åˆ†ç”Ÿæˆå»ºè®®...') {
            lastBotMsg.textContent = 'ç”Ÿæˆå»ºè®®å¤±è´¥';
          }
          return;
        }

        const reader = resp.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let buffer = '';
        let fullText = '';

        const suggestionBotDiv = createStreamingBotMessage();

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const { events, rest } = extractSseEvents(buffer);
          buffer = rest;

          for (const dataStr of events) {
            let obj = null;
            try { obj = JSON.parse(dataStr); } catch (_) {}
            if (!obj) continue;

            if (obj.type === 'delta' && obj.delta) {
              fullText += obj.delta;
              suggestionBotDiv.textContent = fullText;
              chatMessages.scrollTop = chatMessages.scrollHeight;
            } else if (obj.type === 'error') {
              suggestionBotDiv.textContent = `ç”Ÿæˆå»ºè®®é”™è¯¯ï¼š${obj.error}`;
            }
          }
        }

        if (fullText.trim()) {
          chatHistory.push({ role: 'assistant', content: fullText });
        } else {
          suggestionBotDiv.textContent = 'æŠ±æ­‰ï¼Œæˆ‘è¿™æ¬¡æ²¡æœ‰ç”Ÿæˆå‡ºæœ‰æ•ˆå»ºè®®ã€‚';
        }

      } catch (e) {
        const lastBotMsg = chatMessages.lastElementChild;
        if (lastBotMsg?.textContent === 'æ­£åœ¨æ ¹æ®è¯„åˆ†ç”Ÿæˆå»ºè®®...') {
          lastBotMsg.textContent = (e.name === 'AbortError')
            ? 'ç”Ÿæˆå»ºè®®è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•ã€‚'
            : 'ç”Ÿæˆå»ºè®®å¤±è´¥ï¼š' + e.message;
        }
      } finally {
        clearTimeout(timeoutId);
        controller.abort();
      }
    }

    function drawScoreChart(result) {
      const chartBars = document.getElementById('chartBars');
      if (!chartBars) return;

      const scores = result.scores || [];
      if (scores.length === 0) {
        chartBars.innerHTML = '<p style="color:#999;">æš‚æ— è¯„åˆ†æ•°æ®</p>';
        return;
      }

      chartBars.innerHTML = '';
      scores.forEach(item => {
        const barHeight = (item.score / 5) * 160;
        const displayName = TECH_NAME_MAP[item.technique] || item.technique;
        const barItem = document.createElement('div');
        barItem.className = 'chart-bar-item';
        barItem.innerHTML = `
          <span class="chart-bar-value">${item.score}</span>
          <div class="chart-bar" style="height:${barHeight}px;"></div>
          <span class="chart-bar-label" title="${displayName}">${displayName}</span>
        `;
        chartBars.appendChild(barItem);
      });
    }

    function showError(message) {
      const resultsDiv = document.getElementById('scoringResults');
      if (!resultsDiv) return;
      resultsDiv.innerHTML = `<div class="error"><p>${message}</p></div>`;
      resultsDiv.style.display = 'block';
    }

    // =========================
    // åˆå§‹åŒ–
    // =========================
    window.addEventListener('load', () => {
      initVoiceRecognition();
      voiceButton.addEventListener('click', toggleRecording);

      ttsToggleBtn.addEventListener('click', async () => {
        ttsEnabled = !ttsEnabled;

        if (ttsEnabled) {
          ttsToggleBtn.textContent = 'ğŸ”Š';
          try {
            await connectTts();
            startTtsFlushTimer();
          } catch (e) {
            console.error(e);
          }
        } else {
          ttsToggleBtn.textContent = 'ğŸ”‡';
          closeTts();
        }
      });

      window.addEventListener('beforeunload', () => {
        try { closeTts(); } catch (_) {}
      });
    });

    document.addEventListener('DOMContentLoaded', () => {
      const audioFileElement = document.getElementById('audioFile');
      if (audioFileElement) {
        audioFileElement.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            const label = document.querySelector('.file-label');
            if (label) label.textContent = `ğŸ“ ${file.name}`;
          }
        });
      }

      const audioScoringModal = document.getElementById('audioScoringModal');
      if (audioScoringModal) {
        audioScoringModal.addEventListener('click', (e) => {
          if (e.target === audioScoringModal) closeAudioScoringModal();
        });
      }

      const scoreVoiceModal = document.getElementById('scoreVoiceModal');
      if (scoreVoiceModal) {
        scoreVoiceModal.addEventListener('click', (e) => {
          if (e.target === scoreVoiceModal) closeScoreVoiceModal();
        });
      }
    });
  </script>
</body>
</html>
